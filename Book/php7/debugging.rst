Debugging with GDB
==================

This chapter will introduce you with the GNU C debugger, aka GDB. When a crash happens, you usually have to find the 
guilty part in thousands of lines. You need tools for that, and GDB is the most commonly used debugger under Unix 
platforms. Here we'll give you an introduction to GDB and how to practice with it against the PHP source code.

Segfault
--------

Let's start with a piece of bad code. This PHP ``hello`` function prints "hello" with an upper case “H”, but there are
some programming mistakes in the code.

    .. code-block:: c

        /* for toupper() */
        #include <ctype.h>

        PHP_FUNCTION(hello) {
          char *name = NULL;
          char *hello = "hello";
          size_t name_len = 0;

          hello[0] = toupper(hello[0]);

          if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &name, &name_len) == FAILURE) {
              return;
          }

          php_printf("%s %s\n", hello, name);
          RETURN_TRUE;
        }

Let's see what happens when we run it:

    .. code-block:: bash

        $ php -dextension=modules/hello.so -a
        Interactive shell

        php > hello('world');
        Segmentation fault

Now what?

Get a coredump
--------------

Enable coredumps and run the program again:

    .. code-block:: bash

        ulimit -c unlimited


    .. code-block:: bash

        $ php -dextension=modules/hello.so -r "hello('world');"
        Segmentation fault (core dumped)


A file named ``core`` will be created. Now let's run the GNU debugger on php with this coredump to locate the problem:

    .. code-block:: bash

        $ gdb php core
        ...
        Core was generated by `php -dextension=modules/hello.so -r hello('world');'.
        Program terminated with signal SIGSEGV, Segmentation fault.
        #0  0x00007fe35992896e in zif_hello (execute_data=0x7fe35a6130a0, return_value=0x7fe35a613090) at .../hello.c:42
        42	  hello[0] = toupper(hello[0]);

It immediately points out that there is a problem with the ``toupper()`` in ``hello.c`` at line 42. It will not always
be this obvious, sometimes you want to get a backtrace to see how you got at this line. Run ``bt`` to get a full stack
trace:

    .. code-block:: bash

        (gdb) bt
        #0  0x00007fe35992896e in zif_hello (execute_data=0x7fe35a6130a0, return_value=0x7fe35a613090) at .../hello.c:42
        #1  0x0000000000b052d8 in ZEND_DO_ICALL_SPEC_HANDLER () at .../Zend/zend_vm_execute.h:586
        #2  0x0000000000b04d04 in execute_ex (ex=0x7fe35a613030) at .../Zend/zend_vm_execute.h:414
        #3  0x0000000000b04e15 in zend_execute (op_array=0x7fe35a682000, return_value=0x7ffc179a0af0) at .../Zend/zend_vm_execute.h:458
        #4  0x0000000000a8ea37 in zend_eval_stringl (str=0x1b1a680 "hello('world');", str_len=15, retval_ptr=0x0, string_name=0x1138ae4 "Command line code")
            at .../Zend/zend_execute_API.c:1135
        #5  0x0000000000a8ec5c in zend_eval_stringl_ex (str=0x1b1a680 "hello('world');", str_len=15, retval_ptr=0x0, string_name=0x1138ae4 "Command line code",
            handle_exceptions=1) at .../Zend/zend_execute_API.c:1176
        #6  0x0000000000a8ece2 in zend_eval_string_ex (str=0x1b1a680 "hello('world');", retval_ptr=0x0, string_name=0x1138ae4 "Command line code", handle_exceptions=1)
            at .../Zend/zend_execute_API.c:1187
        #7  0x0000000000b6df9d in do_cli (argc=4, argv=0x1b3dcb0) at .../sapi/cli/php_cli.c:1005
        #8  0x0000000000b6f065 in main (argc=4, argv=0x1b3dcb0) at .../sapi/cli/php_cli.c:1344

You can also step debug it. Run the program again under gdb and set a breakpoint on line 38.

    .. code-block:: bash

        $ gdb --args php -dextension=modules/hello.so -r "hello('world');"
        ...
        (gdb) break hello.c:38
        No source file named hello.c.
        Make breakpoint pending on future shared library load? (y or [n]) y
        Breakpoint 1 (hello.c:38) pending.

Then actually run the program and step through it.

    .. code-block:: bash

        (gdb) run
        Starting program: php -dextension=modules/hello.so -r hello\(\'world\'\)\;

        Breakpoint 1, zif_hello (execute_data=0x7fffecc130a0, return_value=0x7fffecc13090) at .../hello.c:38
        38	  char *name = NULL;
        (gdb) s
        39	  char *hello = "hello";
        (gdb) s
        40	  size_t name_len = 0;
        (gdb) s
        42	  hello[0] = toupper(hello[0]);
        (gdb) print hello
        $1 = 0x7fffebf28a09 "hello"
        (gdb) s
        toupper (c=104) at ctype.c:52
        52	  return c >= -128 && c < 256 ? __ctype_toupper[c] : c;
        (gdb) s
        53	}
        (gdb) s

        Program received signal SIGSEGV, Segmentation fault.
        0x00007fffebf2896e in zif_hello (execute_data=0x7fffecc130a0, return_value=0x7fffecc13090) at .../hello.c:42
        42	  hello[0] = toupper(hello[0]);

The crash is caused by the ``char *hello = "hello";`` that should have been a ``char hello[] = "hello";``. Rookie
mistake, read "The C programming language" (K&R) section 5.5 "Character Pointers and Functions" for more information.

Memory leaks
------------

Let's make the function leak some memory by allocating 128 bytes of memory and not releasing it:

    .. code-block:: c

        PHP_FUNCTION(hello) {
          char *name = NULL;
          size_t name_len = 0;

          emalloc(128);

          if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &name, &name_len) == FAILURE) {
              return;
          }

          php_printf("Hello %s\n", name);
          RETURN_TRUE;
        }


Let's see what happens when we run it:

    .. code-block:: bash

        $ php -dextension=modules/hello.so -r "hello('world');"
        Hello world
        [Sun Jul 24 17:30:07 2016]  Script:  '-'
        .../hello.c(38) :  Freeing 0x7F25B10731E0 (128 bytes), script=-
        === Total 1 memory leaks detected ===

If PHP is built with ``--enable-debug`` and the ini flag ``report_memleaks`` is ``On`` (this is by default), memory
leaks will be reported. You can turn it off and PHP will no longer print info about the leak:

    .. code-block:: bash

        $ php -dreport_memleaks=Off -dextension=modules/hello.so -r "hello('world');"
        Hello world

The reason why the engine detects the leak is because ``emalloc()`` is part of the PHP API and it tracks allocations.
Never use the system default allocators like ``malloc()`` to work with memory, the engine will not detect leaks.
More information about PHP memory API at http://php.net/manual/en/internals2.memory.management.php

Tools like Valgrind can help you debug memory leaks.
